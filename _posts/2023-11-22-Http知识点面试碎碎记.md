---
title: Http知识点面试碎碎记
date: 2023-11-22 20:00:00
categories: [面试碎碎记]
tags: [http]
---

**Okhttp 缓存：**

【2.3.3】相关请求头

1. **Last-Modified/If-Modified-Since：xxx** 在服务器首次请求回来的数据的请求头，附带了Last-Modified:xxx。这个时间值会在下次请求时，被附带在If-Modified-Since的请求值里。服务器对比两个值，如果一至就返回304状态码，告知客户端继续使用缓存。如果不一致，服务器返回新的Expires和Last-Modifed。缺点：Last-Modified只能精确到秒级，如果一个文件在1s内被更改，那么他们的值Last-Modified值是一样的，这会导致更新不到新资源问题。
2. **ETag/If-Not-Match：** 鉴于上面Last-Modified的缺点，增加了一个新的字段。服务器通过某种算法，对资源进行计算，比如MD5，然后赋值在Etag返回到客户端。客户端下次请求将值赋值到If-Not-Match/或者If-Match上，服务器进行比较，如果一致则直接返回304状态码，通知客户端可以使用缓存。如果需要更新，那么状态码为200，并返回整个新的资源。并且他们的优先级高于**Last-Modified/If-Modified-Since**



**浏览器输入地址到返回结果发生了什么？**

1、DNS解析，此外还有DNSy优化（DNS缓存、DNS负载均衡）

2、TCP连接

3、发送HTTP请求

4、服务器处理请求并返回HTTP报文

5、浏览器解析渲染页面

6、连接结束



**Http的request和response的协议组成**

**1、Request组成**

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

**2、Response组成**

一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。



**TCP 可靠传输原理实现（滑动窗口）**

确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。

数据校验，数据合理分片与排序，TCP 会对数据进行分片，接收方会缓存为按序到达的数据，重新排序 后再提交给应用层。

流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢 失。

拥塞控制：当网络发生拥塞时，减少数据的发送。



**HTTPS 中的 SSL 握手建立过程**

假设现在有客户端 A 和服务器 B ：

1、首先，客户端A访问服务器B，客户端 A 会生成一个随机数 1，把随机数 1 、自己支持的 SSL 版本号以及 加密算法等这些信息告诉服务器 B 。

2、服务器 B 知道这些信息后，然后确认一下双方的加密算法，然后服务端也生成

一个随机数 2，并将随机数 B 和 CA 颁发给自己的证书一同返回给客户端 A 。

3、客户端 A 得到 CA 证书后，会去校验该 CA 证书的有效性，校验方法在上面

已经说过了。校验通过后，客户端生成一个随机数 3 ，然后用证书中的公钥加密随

机数 3 并传输给服务端 B 。

4、服务端 B 得到加密后的随机数 3，然后利用私钥进行解密，得到真正的随机数

3。

5、最后，客户端 A 和服务端 B 都有随机数 1、随机数 2、随机数 3，然后双方利

用这三个随机数生成一个对话密钥。之后传输内容就是利用对话密钥来进行加解密

了。这时就是利用了对称加密，一般用的都是 AES 算法。

6、客户端 A 通知服务端 B ，指明后面的通讯用对话密钥来完成，同时通知服务

器 B 客户端 A 的握手过程结束。

7、服务端 B 通知客户端 A，指明后面的通讯用对话密钥来完成，同时通知客户端

A 服务器 B 的握手过程结束。

8、SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 A 和服务器 B 开

始使用相同的对话密钥进行数据通讯。

**简化如下：**

1、客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；

2、互相传递三个随机数，之后通过这随机数来生成一个密钥；

3、互相确认密钥，然后握手结束；

4、数据通讯开始，都使用同一个对话密钥来加解密；

可以发现，在 HTTPS 加密原理的过程中把对称加密和非对称加密都利用了起来。即利用了

非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处。



**客户端如何校验 CA 证书？**

CA 证书中的 Hash 值，其实是用证书的私钥进行加密后的值（证书的私钥不在 CA 证书中）。然后客户端得到证书后，利用证书中的公钥去解密该 Hash 值，得到 Hash-a ；然后再利用证书内的签名 Hash 算法去生成一个 Hash-b 。最后比较 Hash-a 和 Hash-b 这 两个的值。如果相等，那么证明了该证书是对的，服务端是可以被信任的；如果不相等，那 么就说明该证书是错误的，可能被篡改了，浏览器会给出相关提示，无法建立起 HTTPS 连 接。除此之外，还会校验 CA 证书的有效时间和域名匹配等。



**HTTP2.0 和 HTTP1.X 相比的新特性**

新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本。基于文本协议的 格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然 很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定 采用二进制格式，实现方便且健壮。

多路复用（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机 制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属 到各自不同的服务端请求里面。

header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而 且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯 双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需 要传输的大小。

服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。



**SPDY与HTTP 1.1的区别？**

1、多路复用机制。降低延迟，针对HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。 多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的 问题，降低了延迟同时提高了带宽的利用率。

2、请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接 共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先 级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应 该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能 第一时间看到网页内容。

3、header 压缩。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适 的压缩算法可以减小包的大小和数量。

4、基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。

5、服务端推送（server push），采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户 端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。



**HTTP1.0 和 HTTP1.1 的一些区别?**

1、缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做 为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag， If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓 存策略。

2、断点续传，HTTP1.0 中，存在一些浪费带宽的现象，例如客户 端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点 续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分， 即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利 用带宽和连接。

3、错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict） 表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资 源被永久性的删除。

4、Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此， 请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展， 在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求 消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

5、长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线 （Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建 立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一 定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。



**HTTP与HTTPS的区别？**

如果 URL 的协议是 HTTP，则客户端会打开一条到服务端端口 80（默认）的连接，并向其 发送老的 HTTP 请求。 如果 URL 的协议是 HTTPS，则客户端会打开一条到服务端端口 443 （默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些 SSL 的安全参数，附 上加密的 HTTP 请求。 所以你可以看到，HTTPS 比 HTTP 多了一层与 SSL 的连接，这也就 是客户端与服务端 SSL 握手的过程，整个过程主要完成以下工作：

交换协议版本号 选择一个两端都了解的密码 对两端的身份进行认证 生成临时的会话密 钥，以便加密信道。